{
  "version": 3,
  "sources": ["../../src/app/querys.ts"],
  "sourcesContent": ["import { useConnection } from \"../connection\";\r\nimport type { TableItem } from \"../lib/adapter-config\";\r\nimport type { SqlIobrokerAdapterRow, TableSize } from \"../types/types\";\r\nimport { isDefined, roundValue } from \"../lib/lib\";\r\n\r\nexport async function createNewTable(table: string): Promise<void> {\r\n    return useConnection(async (connection) => {\r\n        const query = `\r\n            CREATE TABLE IF NOT EXISTS ${table}\r\n            (\r\n                id\r\n                    INT,\r\n                ts\r\n                    BIGINT,\r\n                val\r\n                    DOUBLE,\r\n                unit\r\n                    VARCHAR(50),\r\n                createdAt\r\n                    TIMESTAMP\r\n                    DEFAULT\r\n                        CURRENT_TIMESTAMP\r\n            )`;\r\n        await connection.query(query);\r\n    });\r\n}\r\n\r\nexport const saveData = async (entry: TableItem, date: number, val: number): Promise<void> => {\r\n    return useConnection(async (connection) => {\r\n        const saveQuery = `INSERT INTO ${entry.tableTo} (id, ts, val, unit)\r\n                           VALUES (?, ?, ?, ?)`;\r\n        if (!isDefined(val)) {\r\n            return;\r\n        }\r\n        await connection.execute(saveQuery, [entry.id, date, roundValue(entry, val), entry.unit ?? \"\"]);\r\n    });\r\n};\r\n\r\nexport const saveDataArray = async (entry: TableItem, table: SqlIobrokerAdapterRow[]): Promise<void> => {\r\n    return useConnection(async (connection) => {\r\n        const saveQuery = `INSERT INTO ${entry.tableTo} (id, ts, val, unit)\r\n                           VALUES (?, ?, ?, ?)`;\r\n\r\n        for (const row of table) {\r\n            if (!isDefined(row.val)) {\r\n                continue;\r\n            }\r\n            if (row.val === 0 && !entry.writeZero) {\r\n                continue;\r\n            }\r\n            await connection.execute(saveQuery, [entry.id, row.ts, roundValue(entry, row.val), entry.unit ?? \"\"]);\r\n        }\r\n    });\r\n};\r\n\r\nexport const getAllTables = async (): Promise<string[]> => {\r\n    return useConnection(async (connection) => {\r\n        const [rows] = await connection.query(\"SHOW TABLES\");\r\n\r\n        const result = rows as Record<string, string>[];\r\n\r\n        return result.map((row): string => {\r\n            return Object.keys(row).map((key) => row[key])[0];\r\n        });\r\n    });\r\n};\r\n\r\nexport const setTimeZone = async (timeZone?: string): Promise<void> => {\r\n    if (timeZone === \"0\" || !timeZone) {\r\n        return;\r\n    }\r\n    return await useConnection(async (connection) => {\r\n        const query = `SET time_zone = ?`;\r\n        await connection.query(query, timeZone);\r\n    });\r\n};\r\n\r\nexport const getTableSize = async (database: string, table: string): Promise<TableSize> => {\r\n    return await useConnection(async (connection): Promise<TableSize> => {\r\n        const [rows] = await connection.execute(\r\n            `SELECT table_name                                             AS \"table\",\r\n                    round(((data_length + index_length) / 1024 / 1024), 2) AS \"size_(MB)\"\r\n             FROM information_schema.TABLES\r\n             WHERE table_schema = ?\r\n               AND table_name = ?;\r\n            `,\r\n            [database, table],\r\n        );\r\n\r\n        if ((rows as TableSize[]).length) {\r\n            return (rows as TableSize[])[0];\r\n        }\r\n        throw new Error(`Tabelle ${table} nicht gefunden.`);\r\n    });\r\n};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAA8B;AAG9B,iBAAsC;AAEtC,eAAsB,eAAe,OAA8B;AAC/D,aAAO,iCAAc,OAAO,eAAe;AACvC,UAAM,QAAQ;AAAA,yCACmB,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAetC,UAAM,WAAW,MAAM,KAAK;AAAA,EAChC,CAAC;AACL;AAEO,MAAM,WAAW,OAAO,OAAkB,MAAc,QAA+B;AAC1F,aAAO,iCAAc,OAAO,eAAe;AA5B/C;AA6BQ,UAAM,YAAY,eAAe,MAAM,OAAO;AAAA;AAE9C,QAAI,KAAC,sBAAU,GAAG,GAAG;AACjB;AAAA,IACJ;AACA,UAAM,WAAW,QAAQ,WAAW,CAAC,MAAM,IAAI,UAAM,uBAAW,OAAO,GAAG,IAAG,WAAM,SAAN,YAAc,EAAE,CAAC;AAAA,EAClG,CAAC;AACL;AAEO,MAAM,gBAAgB,OAAO,OAAkB,UAAkD;AACpG,aAAO,iCAAc,OAAO,eAAe;AAvC/C;AAwCQ,UAAM,YAAY,eAAe,MAAM,OAAO;AAAA;AAG9C,eAAW,OAAO,OAAO;AACrB,UAAI,KAAC,sBAAU,IAAI,GAAG,GAAG;AACrB;AAAA,MACJ;AACA,UAAI,IAAI,QAAQ,KAAK,CAAC,MAAM,WAAW;AACnC;AAAA,MACJ;AACA,YAAM,WAAW,QAAQ,WAAW,CAAC,MAAM,IAAI,IAAI,QAAI,uBAAW,OAAO,IAAI,GAAG,IAAG,WAAM,SAAN,YAAc,EAAE,CAAC;AAAA,IACxG;AAAA,EACJ,CAAC;AACL;AAEO,MAAM,eAAe,YAA+B;AACvD,aAAO,iCAAc,OAAO,eAAe;AACvC,UAAM,CAAC,IAAI,IAAI,MAAM,WAAW,MAAM,aAAa;AAEnD,UAAM,SAAS;AAEf,WAAO,OAAO,IAAI,CAAC,QAAgB;AAC/B,aAAO,OAAO,KAAK,GAAG,EAAE,IAAI,CAAC,QAAQ,IAAI,GAAG,CAAC,EAAE,CAAC;AAAA,IACpD,CAAC;AAAA,EACL,CAAC;AACL;AAEO,MAAM,cAAc,OAAO,aAAqC;AACnE,MAAI,aAAa,OAAO,CAAC,UAAU;AAC/B;AAAA,EACJ;AACA,SAAO,UAAM,iCAAc,OAAO,eAAe;AAC7C,UAAM,QAAQ;AACd,UAAM,WAAW,MAAM,OAAO,QAAQ;AAAA,EAC1C,CAAC;AACL;AAEO,MAAM,eAAe,OAAO,UAAkB,UAAsC;AACvF,SAAO,UAAM,iCAAc,OAAO,eAAmC;AACjE,UAAM,CAAC,IAAI,IAAI,MAAM,WAAW;AAAA,MAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,CAAC,UAAU,KAAK;AAAA,IACpB;AAEA,QAAK,KAAqB,QAAQ;AAC9B,aAAQ,KAAqB,CAAC;AAAA,IAClC;AACA,UAAM,IAAI,MAAM,WAAW,KAAK,kBAAkB;AAAA,EACtD,CAAC;AACL;",
  "names": []
}
